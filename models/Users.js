// @author: Maryam Archie

/**
 * Model representing the users of the application. Each user is represented as
 * an object. Usernames, emails and passwords are strings and are all required
 * during the creation of a user. A user's rep(utation) is a Number that defaults
 * to 0 upon creation. It is the sum of the number of Spots that the user has created
 * and the sum of the differences between the number of likes and dislikes for each review
 * that he/she has written. A user's favorites is a list of Spots that the he/she liked.
 * 
 * Based off fritter-marchie and fritter-react
 */

var mongoose = require("mongoose");
mongoose.Promise = require("bluebird");
var bcrypt = require("bcryptjs");
const SALT_WORK_FACTOR = 10;

const BAD_REQUEST = 400;
const FORBIDDEN = 403;
const NOT_FOUND = 404;
const USER_NOT_FOUND = "User cannot be found.";

const MIN_LENGTH = 3;
const MAX_LENGTH = 15;

var userSchema = mongoose.Schema({
    username: {
        type: String,
        unique: true,
        required: true
    },
    email: {
        type: String,
        unique: true,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    rep: {
        type: Number,
        default: 0
    },
    favorites: [
        { type: mongoose.Schema.Types.ObjectId, required: false, ref: "Spot" }
    ]
});

/**
 * Serial Mongoose Middleware that salts and hashes a user's password before
 * saving the User object to the database.
 * @param {function} next - callback function that calls the next piece of middleware
 */
userSchema.pre("save", function (next) {
    var user = this;
    bcrypt.genSalt(SALT_WORK_FACTOR, function (err, salt) {
        if (err) {
            return next(err);
        } else {
            bcrypt.hash(user.password, salt, function (err, hash) {
                if (err) {
                    return next(err);
                } else {
                    user.password = hash;
                    next();
                }
            });
        }
    });
});

var userModel = mongoose.model("User", userSchema);

var User = function (userModel) {

    var that = Object.create(User.prototype);

    /**
     * Determines whether the username and email are valid.
     * The length of a username must be between 3 and 15 characters and must only
     * contain alphanumeric characters.
     * The email must be a valid MIT email address, i.e. end with @mit.edu.
     * N.B. These fields are case sensitive
     * @param {String} username - the username that a User tries to register with
     * @param {String} email - the email address that a User tries to register with
     * @param {String} password - the password that a User tried to register with
     * @return {any} Error message if the username/ email is invalid, null otherwise
     */
    var checkRep = function (username, email, password) {
        var isAlphanumeric = /^[a-zA-Z0-9]+$/.test(username);
        var isCorrectLength = username.length >= MIN_LENGTH && username.length <= MAX_LENGTH;
        var isValidUsername = isAlphanumeric && isCorrectLength;
        var isValidEmail = /^[a-zA-Z0-9._-]+@mit.edu$/.test(email);
        var isValidPassword = /^[^\s]+$/.test(password) && password.length >= MIN_LENGTH;
        if (!isValidUsername) {
            return "Usernames must be between 3 and 15 non-whitespace characters.";
        }
        else if (!isValidEmail) {
            return "Please use a valid MIT email.";
        }
        else if (!isValidPassword) {
            return "Passwords must be at least 3 non-whitespace characters.";
        }
        else {
            return null;
        }
    };

    /**
     * Helper function that handles errors
     * @param {Object} err - err.http_status: known errors generated by model
     *                       otherwise, unknown errors
     * @param {function} callback - the callback function
     */
    var errorHandler = function (err, callback) {
        if (err.http_status) {
            callback({ msg: err.msg, http_status: err.http_status });
        } else {
            callback({ msg: err });
        }
    };

    /**
     * Create a new User. If one already exists, send an error to the user.
     * @param {String} username - the username of a User
     * @param {String} email - the @mit.edu email address of a User
     * @param {String} password - the password that the User will use to access their account
     * @param {function} callback - the callback function
     *                              must be called with (err, newUser) as params
     */
    that.createUser = function (username, email, password, callback) {
        var isInvalid = checkRep(username, email, password);
        if (!isInvalid) {
            var user = new userModel({ username: username, email: email, password: password, favorites: [] });
            user.save(function (err, user) {
                // There was a problem registering
                if (err) {
                    // Duplicate email/ username
                    if (err.code === 11000) {
                        callback({
                            msg: "This email/username is already in use. Please login or register with a new email/username.",
                            http_status: BAD_REQUEST
                        });
                    }
                    else {
                        callback({ msg: err });
                    }
                }
                // Register user
                else {
                    callback(null, user);
                }
            });
        } else {
            callback({ msg: isInvalid, http_status: BAD_REQUEST });
        }

    };

    /**
     * Finds a User given an email. If the email is valid, return the User object,
     * Otherwise, return an error message.
     * @param {String} email - the email associated with the User of interest
     * @param {function} callback - the callback function 
     */
    that.findUser = function (email, callback) {
        userModel.findOne({ email: email }, function (err, user) {
            // Unknown Error
            if (err) {
                callback({ msg: err });
            } else {
                // User cannot be found 
                if (user === null) {
                    callback({ msg: USER_NOT_FOUND, http_status: NOT_FOUND });
                }
                // Found user
                else {
                    callback(null, user);
                }
            }
        });
    };

    /**
     * Finds a User given an id. If the id is valid, return the User object,
     * Otherwise, return an error message.
     * @param {String} id - the id associated with the User of interest
     * @param {function} callback - the callback function 
     */
    that.findUserById = function (id, callback) {
        userModel.findOne({ _id: id }, function (err, user) {
            if (err) {
                // Unknown error
                callback({ msg: err });
            } else {
                userModel.populate(user, { path: "favorites" }, function (err, user) {
                    // Unknown Error
                    if (err) {
                        callback({ msg: err });
                    } else {
                        if (user === null) {
                            //no user found
                            callback({ msg: USER_NOT_FOUND, http_status: NOT_FOUND });
                        } else {
                            //found user
                            callback(null, user);
                        }
                    }
                });
            }
        });
    };

    /**
     * Determines whether the password inputted by the user is the one that they
     * registered with.
     * Otherwise, return an error message
     * @param {String} email - the email of the User for whom the password is to be validated
     * @param {String} password - the password that the User typed in during login
     * @param {function} callback - callback function
     */
    that.validatePassword = function (email, password, callback) {
        that.findUser(email, function (err, user) {
            if (err) {
                errorHandler(err, callback);
            } else {
                // User exists
                if (user !== null) {
                    bcrypt.compare(password, user.password, function (err, isCorrect) {
                        if (err) {
                            // Unknown Error
                            callback({ msg: err });
                        } else {
                            callback(null, isCorrect);
                        }
                    });
                }
            }
        });
    };

    /**
    * Favorites the spot
    * Otherwise, return an error
    * @param {ObjectId} userId - the id of the user that is favoriting a spot
    * @param {ObjectId} spotId - the id of the spot that is being favorited
    * @param {function} callback - the function to be called after favoriteSpot has executed
    *                              must be called with (err) as the param
    */
    that.favoriteSpot = function (userId, spotId, callback) {
        var Spots = require("../models/Spots").Spots;
        Spots.getSpotById(spotId, function (err, spot) {
            if (err) {
                errorHandler(err, callback);
            } else {
                that.findUserById(userId, function (err, user) {
                    if (err) {
                        errorHandler(err, callback);
                    } else {
                        var favorites = user.favorites;
                        var alreadyFavorited = favorites.filter(function (s) {
                            return (JSON.stringify(s._id) === JSON.stringify(spotId));
                        });
                        if (alreadyFavorited.length !== 0) {
                            callback({ msg: "You have already favorited this spot!", http_status: FORBIDDEN });
                        } else {
                            favorites.push(spot);
                            var favoritesIds = favorites.map(function (spot) {
                                return spot.id;
                            });
                            user.favorites = favoritesIds;
                            userModel.update({ _id: userId }, { favorites: favoritesIds }, function (err) {
                                if (err) {
                                    // Unknown error
                                    callback({ msg: err });
                                } else {
                                    callback(null, user);
                                }
                            });
                        }
                    }
                });
            }
        });
    };

    /**
    * Updates the rep(utation) of the specified user
    * Otherwise, return an error message
    * @param {ObjectId} userId - the id of the user whose rep will be changed
    * @param {Boolean} add - true if 1 will be added to the score, false if 1 will be subtracted from the score
    * @param {function} callback - the function to be called after updateRep has executed
    *                              must be called with (err) as the param
    */
    that.updateRep = function (userId, add, callback) {
        that.findUserById(userId, function (err, user) {
            if (err) {
                // Unknown error
                callback({ msg: err });
            } else {
                if (user === null) {
                    callback({ msg: USER_NOT_FOUND, http_status: NOT_FOUND });
                } else {
                    var rep;
                    if (add) {
                        rep = user.rep + 1;
                    } else {
                        rep = user.rep - 1;
                    }
                    user.rep = rep;
                    userModel.update({ _id: userId }, { rep: rep }, function (err) {
                        if (err) {
                            // Unknown error
                            callback({ msg: err });
                        } else {
                            callback(null, user);
                        }
                    });
                }
            }
        });
    };

    /**
     * Retrieves a User's favorite Spots
     * Otherwise, return an error message
     * @param {ObjectId} userId - the User of interest
     * @param {function} callback - the callback function
     */
    that.getFavoriteSpots = function (userId, callback) {
        that.findUserById(userId, function (err, user) {
            if (err) {
                errorHandler(err, callback);
            } else {
                var favorites = user.favorites;
                callback(null, favorites);
            }
        });
    };

    Object.freeze(that);
    return that;
};

module.exports = { userModel: userModel, Users: User(userModel) };
