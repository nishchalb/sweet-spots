// @author: Isaac Rosado

/**
* Model representing the Reviews of Spots
* Reviews must have a creator (User)
* Reviews must have a description of what the reviewer thought about the Spot
* Reviews must have a quantitative rating of the spot
*/

var mongoose = require("mongoose");
var Users = require("../models/Users").Users;

const BAD_REQUEST = 400;
const FORBIDDEN = 403;
const NOT_FOUND = 404;

var reviewSchema = mongoose.Schema({
    creator: { type: mongoose.Schema.Types.ObjectId, required: true, ref: "User" },
    description: { type: String, required: true },
    rating: { type: Number, required: true },
    score: { type: Number, default: 0 },
    voters: [
        { type: mongoose.Schema.Types.ObjectId, required: false, ref: "User" }
    ]
});

var reviewModel = mongoose.model("Review", reviewSchema);

var Reviews = function(reviewModel) {

    var that = Object.create(Reviews.prototype);

    const RATING_LOWER_LIMIT = 0;
    const RATING_UPPER_LIMIT = 5;
    const DESCRIPTION_UPPER_LIMIT = 500;

	/**
	* Checks that the Review follows the rep invariant
	* @param {String} description - the 500 character description of a User's thoughts about a Spot
	* @param {Number} rating - the integer quantifier of a Review between 0 and 5 (inclusive)
	*/
    var checkRep = function(description, rating) {
        var isValidRating = (rating >= RATING_LOWER_LIMIT && rating <= RATING_UPPER_LIMIT
            && Number.isInteger(rating));
        var isValidDescription = (description.length <= DESCRIPTION_UPPER_LIMIT);
        if (!isValidRating) {
            return "Rating must be an integer between 0 and 5 inclusive!";
        }
        if (!isValidDescription) {
            return "Description must be less than 500 characters!";
        }
        return null;
    };

    /**
     * Helper function that handles errors
     * @param {Object} err - err.http_status: known errors generated by model
     *                       otherwise, unknown errors
     * @param {function} callback - the callback function
     */
    var errorHandler = function(err, callback) {
        if (err.http_status) {
            callback({ msg: err.msg, http_status: err.http_status });
        } else {
            callback({ msg: err });
        }
    };

	/**
	* Adds a Review to the database if the Review does not violate the rep invariant.
	* Otherwise, return an error.
	* @param {ObjectId} creatorId - the id of the creator of the Review
	* @param {String} description - the 500 character description of a User's thoughts about a Spot
	* @param {Number} rating - the integer quantifier of a Review between 0 and 5 (inclusive)
	* @param {function} callback - the function to be called after addReview has executed
    *                              must be called with (err, newReview) as params
	*/
    that.addReview = function(creatorId, description, rating, callback) {
        var isInvalid = checkRep(description, rating);
        if (!isInvalid) {
            var review = new reviewModel({
                creator: creatorId,
                description: description,
                rating: rating,
                voters: []
            });
            Users.findUserById(creatorId, function(err, user) {
                if (err) {
                    callback({ msg: err.msg });
                } else {
                    review.save(function(err, newReview) {
                        if (err) {
                            callback({ msg: err });
                        } else {
                            callback(null, newReview);
                        }
                    });
                }
            });
        } else {
            callback({ msg: isInvalid, http_status: BAD_REQUEST });
        }
    };

	/**
	* Gets the Review with the given id if it exists
    * Otherwise, return an error.
	* @param {ObjectId} reviewId - the id of the Review
	* @param {function} callback - the function to be called after getReviewById has executed
    *                              must be called with (err, review) as params
	*/
    that.getReviewById = function(reviewId, callback) {
        reviewModel.findOne({ _id: reviewId }, function(err, review) {
            if (err) {
                callback({ msg: err });
            } else if (review === null) {
                callback({ msg: "No such review with that id!", http_status: NOT_FOUND });
            } else {
                callback(null, review);
            }
        });
    };

	/**
	* Gets all the Reviews for a specific User
	* Otherwise, return an error.
	* @param {ObjectId} userId - the id of the user whose reviews will be given
	* @param {function} callback - the function to be called after getReviewsByUser has executed
    *                              must be called with (err, reviews) as params
	*/
    that.getReviewsByUser = function(userId, callback) {
        Users.findUserById(userId, function(err, user) {
            if (err) {
                if (err.http_status) {
                    // Error from model function
                    callback({ msg: "User cannot be found.", http_status: NOT_FOUND });
                } else {
                    // Unknown Error
                    callback({ msg: err });
                }
            } else {
                reviewModel.find({ creator: userId }, function(err, reviews) {
                    if (err) {
                        callback({ msg: err });
                    } else {
                        callback(null, reviews);
                    }
                });
            }
        });
    };

    /**
    * Updates the score of the review after an upvote or downvote
    * Otherwise, return an error
    * @param {ObjectId} reviewId - the id of the review whose score will be updated
    * @param {Boolean} upvote - true if the person likes the review, false otherwise
    * @param {function} callback - the function to be called after updateScore has executed
    *                              must be called with (err) as the param
    */
    that.updateScore = function(reviewId, voterId, upvote, callback) {
        that.getReviewById(reviewId, function(err, review) {
            if (err) {
                errorHandler(err, callback);
            } else {
                Users.findUserById(voterId, function(err, voter) {
                    if (err) {
                        errorHandler(err, callback);
                    } else {
                        var voters = review.voters.map(function(previousVoter) {
                            return JSON.stringify(previousVoter);
                        });
                        if (JSON.stringify(voterId) === JSON.stringify(review.creator)) {
                            callback({ msg: "You cannot upvote your own review!", http_status: FORBIDDEN });
                        } else if (voters.indexOf(JSON.stringify(voterId)) > -1) {
                            callback({ msg: "You have already voted on this review!", http_status: FORBIDDEN });
                        } else {
                            review.voters.push(voterId);
                            if (upvote) {
                                review.score += 1;
                            } else {
                                review.score -= 1;
                            }
                            var creatorId = review.creator;
                            Users.updateRep(creatorId, upvote, function(err) {
                                if (err) {
                                    errorHandler(err, callback);
                                } else {
                                    review.save(function(err, review) {
                                        if (err) {
                                            callback({ msg: err });
                                        } else {
                                            callback(null, review);
                                        }
                                    });
                                }
                            });
                        }
                    }
                });
            }
        });
    };

    Object.freeze(that);
    return that;

};

module.exports = { reviewModel: reviewModel, Reviews: Reviews(reviewModel) };
